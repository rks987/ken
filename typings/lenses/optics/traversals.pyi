"""
This type stub file was generated by pyright.
"""

from .base import Traversal

class EachTraversal(Traversal):
    """A traversal that iterates over its state, focusing everything it
    iterates over. It uses `lenses.hooks.fromiter` to reform the state
    afterwards so it should work with any iterable that function
    supports. Analogous to `iter`.

        >>> from lenses import lens
        >>> state = [1, 2, 3]
        >>> EachTraversal()
        EachTraversal()
        >>> EachTraversal().to_list_of(state)
        [1, 2, 3]
        >>> EachTraversal().over(state, lambda n: n + 1)
        [2, 3, 4]

    For technical reasons, this lens iterates over dictionaries by their
    items and not just their keys.

        >>> state = {'one': 1}
        >>> EachTraversal().to_list_of(state)
        [('one', 1)]
    """
    def __init__(self) -> None:
        ...
    
    def folder(self, state): # -> Any:
        ...
    
    def builder(self, state, values): # -> Any:
        ...
    
    def __repr__(self): # -> Literal['EachTraversal()']:
        ...
    


class GetZoomAttrTraversal(Traversal):
    """A traversal that focuses an attribute of an object, though if
    that attribute happens to be a lens it will zoom the lens. This
    is used internally to make lenses that are attributes of objects
    transparent. If you already know whether you are focusing a lens or
    a non-lens you should be explicit and use a ZoomAttrTraversal or a
    GetAttrLens respectively.
    """
    def __init__(self, name) -> None:
        ...
    
    def func(self, f, state): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ItemsTraversal(Traversal):
    """A traversal focusing key-value tuples that are the items of a
    dictionary. Analogous to `dict.items`.

        >>> from collections import OrderedDict
        >>> state = OrderedDict([(1, 10), (2, 20)])
        >>> ItemsTraversal()
        ItemsTraversal()
        >>> ItemsTraversal().to_list_of(state)
        [(1, 10), (2, 20)]
        >>> ItemsTraversal().over(state, lambda n: (n[0], n[1] + 1))
        OrderedDict([(1, 11), (2, 21)])
    """
    def __init__(self) -> None:
        ...
    
    def folder(self, state):
        ...
    
    def builder(self, state, values):
        ...
    
    def __repr__(self): # -> Literal['ItemsTraversal()']:
        ...
    


class RecurTraversal(Traversal):
    """A traversal that recurses through an object focusing everything it
    can find of a particular type. This traversal will probe arbitrarily
    deep into the contents of the state looking for sub-objects. It
    uses some naughty tricks to do this including looking at an object's
    `__dict__` attribute.

    It is somewhat analogous to haskell's uniplate optic.

        >>> RecurTraversal(int)
        RecurTraversal(<... 'int'>)
        >>> data = [[1, 2, 100.0], [3, 'hello', [{}, 4], 5]]
        >>> RecurTraversal(int).to_list_of(data)
        [1, 2, 3, 4, 5]
        >>> class Container(object):
        ...     def __init__(self, contents):
        ...         self.contents = contents
        ...     def __repr__(self):
        ...         return 'Container({!r})'.format(self.contents)
        >>> data = [Container(1), 2, Container(Container(3)), [4, 5]]
        >>> RecurTraversal(int).over(data, lambda n: n+1)
        [Container(2), 3, Container(Container(4)), [5, 6]]
        >>> RecurTraversal(Container).to_list_of(data)
        [Container(1), Container(Container(3))]

    Be careful with this; it can focus things you might not expect.
    """
    def __init__(self, cls) -> None:
        ...
    
    def folder(self, state): # -> Generator[Unknown, None, None]:
        ...
    
    def builder(self, state, values): # -> Any | object:
        ...
    
    def build_object(self, state, values): # -> Any | object:
        ...
    
    def build_object_no_cache(self, state, values): # -> Any:
        ...
    
    def build_from_iter(self, state, values): # -> Any:
        ...
    
    def build_dunder_dict(self, state, values): # -> Any:
        ...
    
    @staticmethod
    def can_iter(state): # -> bool:
        ...
    
    @staticmethod
    def can_hash(state): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ZoomAttrTraversal(Traversal):
    """A lens that looks up an attribute on its target and follows it as
    if were a bound `Lens` object. Ignores the state, if any, of the
    lens that is being looked up.
    """
    def __init__(self, name: str) -> None:
        ...
    
    def func(self, f, state): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ZoomTraversal(Traversal):
    """Follows its state as if it were a bound `Lens` object.

    >>> from lenses import bind
    >>> ZoomTraversal()
    ZoomTraversal()
    >>> state = bind([1, 2])[1]
    >>> ZoomTraversal().view(state)
    2
    >>> ZoomTraversal().set(state, 3)
    [1, 3]
    """
    def __init__(self) -> None:
        ...
    
    def func(self, f, state):
        ...
    
    def __repr__(self): # -> Literal['ZoomTraversal()']:
        ...
    


